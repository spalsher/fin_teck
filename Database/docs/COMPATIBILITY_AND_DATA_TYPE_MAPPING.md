# Compatibility and Data Type Mapping: SQL Server → PostgreSQL

**Purpose**: Migration report for Phase 1 (SQL Server Database Analysis). Use this when designing PostgreSQL schema and converting T-SQL to PL/pgSQL or standard SQL.

---

## 1. Data Type Mapping

| SQL Server Type | PostgreSQL Type | Notes |
|-----------------|-----------------|--------|
| `NVARCHAR(n)` | `VARCHAR(n)` or `TEXT` | Use TEXT if n is large or variable; PG uses UTF-8 by default. |
| `VARCHAR(n)` | `VARCHAR(n)` | Same. |
| `VARCHAR(MAX)` | `TEXT` | No MAX in PG; TEXT is preferred for unbounded. |
| `NCHAR(n)` / `CHAR(n)` | `CHAR(n)` | PG has no separate NCHAR; use VARCHAR(n) if padding not required. |
| `NTEXT` / `TEXT` | `TEXT` | Legacy; map to TEXT. |
| `DATETIME` | `TIMESTAMP` | PG TIMESTAMP is similar; no separate DATE-only time. |
| `DATETIME2(p)` | `TIMESTAMP(p)` | Use TIMESTAMP or TIMESTAMPTZ. |
| `SMALLDATETIME` | `TIMESTAMP` | Round seconds. |
| `DATE` | `DATE` | Same. |
| `TIME(p)` | `TIME(p)` | Same. |
| `BIT` | `BOOLEAN` | 0/1 → false/true. |
| `INT` / `INTEGER` | `INTEGER` | Same. |
| `BIGINT` | `BIGINT` | Same. |
| `SMALLINT` | `SMALLINT` | Same. |
| `TINYINT` | `SMALLINT` | PG has no TINYINT; 0–255 fit in SMALLINT. |
| `IDENTITY(1,1)` | `SERIAL` or `GENERATED ... AS IDENTITY` | Prefer GENERATED BY DEFAULT AS IDENTITY. |
| `BIGINT IDENTITY` | `BIGSERIAL` or `GENERATED ... AS IDENTITY` | Same. |
| `UNIQUEIDENTIFIER` | `UUID` | Enable extension: CREATE EXTENSION "uuid-ossp"; or use gen_random_uuid(). |
| `MONEY` | `NUMERIC(19,4)` | Avoid MONEY in PG for portability. |
| `SMALLMONEY` | `NUMERIC(10,4)` | Same. |
| `DECIMAL(p,s)` / `NUMERIC(p,s)` | `NUMERIC(p,s)` | Same. |
| `REAL` | `REAL` | Same. |
| `FLOAT(n)` | `DOUBLE PRECISION` or `REAL` | Map per precision needs. |
| `IMAGE` / `VARBINARY(MAX)` | `BYTEA` | Binary data. |
| `VARBINARY(n)` | `BYTEA` or `bytea` | Same. |
| `BINARY(n)` | `BYTEA` | Same. |
| `ROWVERSION` / `TIMESTAMP` | `bytea` or application-managed version | No direct equivalent; use trigger-updated column or bytea. |
| `XML` | `XML` or `JSONB` | PG has xml type; consider JSONB for structured data. |
| `HIERARCHYID` | Custom type or path table | No built-in; model as text path or nested set. |

---

## 2. Unsupported / Incompatible Constructs

| Area | SQL Server | PostgreSQL Equivalent |
|------|------------|------------------------|
| **Identity** | `IDENTITY(1,1)` | `SERIAL`, `BIGSERIAL`, or `GENERATED BY DEFAULT AS IDENTITY` |
| **Top N** | `SELECT TOP 10 *` | `SELECT * ... LIMIT 10` |
| **Current time** | `GETDATE()`, `GETUTCDATE()` | `CURRENT_TIMESTAMP`, `CURRENT_TIMESTAMP AT TIME ZONE 'UTC'` |
| **Null coalesce** | `ISNULL(a, b)` | `COALESCE(a, b)` |
| **String concat** | `+` (with possible NULL) | `\|\|` or `CONCAT()` (CONCAT treats NULL as '') |
| **Date arithmetic** | `DATEADD(dd, 1, d)`, `DATEDIFF(dd, a, b)` | `d + INTERVAL '1 day'`, `(b::date - a::date)` |
| **String aggregate** | `STRING_AGG(col, ',')` (2017+) | `STRING_AGG(col, ',')` (same name in PG) |
| **If null** | `ISNULL()` | `COALESCE()` |
| **Collation** | Per-column collation | Database/session collation; use COLLATE "en_US.UTF-8" if needed |
| **Computed columns** | Persisted/non-persisted | Generated columns: `GENERATED ALWAYS AS (expr) STORED` |
| **Indexed views** | Materialized in SQL Server | Use **materialized views** in PG (CREATE MATERIALIZED VIEW) |
| **Schemas** | dbo, etc. | Use `search_path` or schema-qualified names |

---

## 3. Risk Areas

- **Complex T-SQL**: Cursors, temp tables (#t), CTEs using SQL Server–only functions → rewrite in plpgsql or application code.
- **Triggers**: `inserted` / `deleted` tables → use `NEW` / `OLD` and transition tables in PG (e.g. `REFERENCING NEW TABLE AS new_table` in PG 10+).
- **Cross-database references**: Three-part names (`db.schema.table`) → not supported in PG; use FDW or single database.
- **Replication-specific code**: Replication procedures → replace with PG logical replication or application-level sync.
- **Stored procedures returning result sets**: Use `RETURNS TABLE(...)` or `OUT` parameters in PG functions.

---

## 4. Dependencies (Directed Graph)

Document after running inventory scripts:

- **Tables**: Parent tables (referenced by FK) must be created before child tables. Order: no-FK tables first, then by FK dependency.
- **Views**: Depend on underlying tables/views; create after tables.
- **Procedures/Functions**: Depend on tables/views; create after objects they reference.
- **Triggers**: Depend on tables; create after table and function exist.

Use output of `02-keys-and-constraints.sql` and `03-programmability.sql` to build the dependency graph (e.g. in the Migration Report or a separate diagram).

---

## 5. How to Use This Document

1. **Schema design (Phase 2)**: When creating PostgreSQL DDL, apply the type mapping in §1.
2. **Data migration**: Ensure ETL converts types per §1 (e.g. BIT → boolean, UNIQUEIDENTIFIER → uuid).
3. **Programmability (Phase 2.3)**: When converting procedures/views/triggers, replace constructs per §2 and avoid risks in §3.
4. **Order of creation**: Follow dependency order implied by §4.

---

*Generated for SQL Server to PostgreSQL and .NET Multi-Tenant Migration plan. Source databases: ATS_HRMS, ATS_GL_Test (as documented in Database/README-iteck_erp.md and appsettings).*
